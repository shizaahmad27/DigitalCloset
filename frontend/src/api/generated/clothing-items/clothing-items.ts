/**
 * Generated by orval v7.9.0 üç∫
 * Do not edit manually.
 * Digital Closet API
 * API for managing your digital closet
 * OpenAPI spec version: 1.0
 */
import { useInfiniteQuery, useMutation, useQuery } from "@tanstack/vue-query";
import type {
  DataTag,
  InfiniteData,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UseInfiniteQueryOptions,
  UseInfiniteQueryReturnType,
  UseMutationOptions,
  UseMutationReturnType,
  UseQueryOptions,
  UseQueryReturnType,
} from "@tanstack/vue-query";

import { computed, unref } from "vue";
import type { MaybeRef } from "vue";

import type {
  ClothingItem,
  GetAll1Params,
  GetByCategoryParams,
  GetByEventTypeParams,
  GetByTagParams,
  PageClothingItem,
  SearchByNameParams,
  Unit,
} from ".././model";

import { customInstance } from "../../mutator/custom-instance";

/**
 * @summary Get a clothing item by ID
 */
export const getById1 = (id: MaybeRef<number>, signal?: AbortSignal) => {
  id = unref(id);

  return customInstance<ClothingItem>({
    url: `/api/clothing-items/${id}`,
    method: "GET",
    signal,
  });
};

export const getGetById1QueryKey = (id: MaybeRef<number>) => {
  return ["api", "clothing-items", id] as const;
};

export const getGetById1InfiniteQueryOptions = <
  TData = InfiniteData<Awaited<ReturnType<typeof getById1>>>,
  TError = unknown,
>(
  id: MaybeRef<number>,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getById1>>,
        TError,
        TData
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getGetById1QueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getById1>>> = ({
    signal,
  }) => getById1(id, signal);

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(id)),
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getById1>>,
    TError,
    TData
  >;
};

export type GetById1InfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getById1>>
>;
export type GetById1InfiniteQueryError = unknown;

/**
 * @summary Get a clothing item by ID
 */

export function useGetById1Infinite<
  TData = InfiniteData<Awaited<ReturnType<typeof getById1>>>,
  TError = unknown,
>(
  id: MaybeRef<number>,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getById1>>,
        TError,
        TData
      >
    >;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetById1InfiniteQueryOptions(id, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

export const getGetById1QueryOptions = <
  TData = Awaited<ReturnType<typeof getById1>>,
  TError = unknown,
>(
  id: MaybeRef<number>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getById1>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getGetById1QueryKey(id);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getById1>>> = ({
    signal,
  }) => getById1(id, signal);

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(id)),
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getById1>>, TError, TData>;
};

export type GetById1QueryResult = NonNullable<
  Awaited<ReturnType<typeof getById1>>
>;
export type GetById1QueryError = unknown;

/**
 * @summary Get a clothing item by ID
 */

export function useGetById1<
  TData = Awaited<ReturnType<typeof getById1>>,
  TError = unknown,
>(
  id: MaybeRef<number>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getById1>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetById1QueryOptions(id, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * @summary Update an existing clothing item
 */
export const update1 = (
  id: MaybeRef<number>,
  clothingItem: MaybeRef<ClothingItem>,
) => {
  id = unref(id);
  clothingItem = unref(clothingItem);

  return customInstance<ClothingItem>({
    url: `/api/clothing-items/${id}`,
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    data: clothingItem,
  });
};

export const getUpdate1MutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof update1>>,
    TError,
    { id: number; data: ClothingItem },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof update1>>,
  TError,
  { id: number; data: ClothingItem },
  TContext
> => {
  const mutationKey = ["update1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof update1>>,
    { id: number; data: ClothingItem }
  > = (props) => {
    const { id, data } = props ?? {};

    return update1(id, data);
  };

  return { mutationFn, ...mutationOptions };
};

export type Update1MutationResult = NonNullable<
  Awaited<ReturnType<typeof update1>>
>;
export type Update1MutationBody = ClothingItem;
export type Update1MutationError = unknown;

/**
 * @summary Update an existing clothing item
 */
export const useUpdate1 = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof update1>>,
      TError,
      { id: number; data: ClothingItem },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof update1>>,
  TError,
  { id: number; data: ClothingItem },
  TContext
> => {
  const mutationOptions = getUpdate1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Delete a clothing item
 */
export const delete1 = (id: MaybeRef<number>) => {
  id = unref(id);

  return customInstance<Unit>({
    url: `/api/clothing-items/${id}`,
    method: "DELETE",
  });
};

export const getDelete1MutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof delete1>>,
    TError,
    { id: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof delete1>>,
  TError,
  { id: number },
  TContext
> => {
  const mutationKey = ["delete1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof delete1>>,
    { id: number }
  > = (props) => {
    const { id } = props ?? {};

    return delete1(id);
  };

  return { mutationFn, ...mutationOptions };
};

export type Delete1MutationResult = NonNullable<
  Awaited<ReturnType<typeof delete1>>
>;

export type Delete1MutationError = unknown;

/**
 * @summary Delete a clothing item
 */
export const useDelete1 = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof delete1>>,
      TError,
      { id: number },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof delete1>>,
  TError,
  { id: number },
  TContext
> => {
  const mutationOptions = getDelete1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Get all clothing items with pagination
 */
export const getAll1 = (
  params?: MaybeRef<GetAll1Params>,
  signal?: AbortSignal,
) => {
  params = unref(params);

  return customInstance<PageClothingItem>({
    url: `/api/clothing-items`,
    method: "GET",
    params: unref(params),
    signal,
  });
};

export const getGetAll1QueryKey = (params?: MaybeRef<GetAll1Params>) => {
  return ["api", "clothing-items", ...(params ? [params] : [])] as const;
};

export const getGetAll1InfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof getAll1>>,
    GetAll1Params["page"]
  >,
  TError = unknown,
>(
  params?: MaybeRef<GetAll1Params>,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getAll1>>,
        TError,
        TData,
        Awaited<ReturnType<typeof getAll1>>,
        QueryKey,
        GetAll1Params["page"]
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getGetAll1QueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getAll1>>,
    QueryKey,
    GetAll1Params["page"]
  > = ({ signal, pageParam }) =>
    getAll1(
      { ...unref(params), page: pageParam || unref(params)?.["page"] },
      signal,
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getAll1>>,
    TError,
    TData,
    Awaited<ReturnType<typeof getAll1>>,
    QueryKey,
    GetAll1Params["page"]
  >;
};

export type GetAll1InfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getAll1>>
>;
export type GetAll1InfiniteQueryError = unknown;

/**
 * @summary Get all clothing items with pagination
 */

export function useGetAll1Infinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof getAll1>>,
    GetAll1Params["page"]
  >,
  TError = unknown,
>(
  params?: MaybeRef<GetAll1Params>,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getAll1>>,
        TError,
        TData,
        Awaited<ReturnType<typeof getAll1>>,
        QueryKey,
        GetAll1Params["page"]
      >
    >;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAll1InfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

export const getGetAll1QueryOptions = <
  TData = Awaited<ReturnType<typeof getAll1>>,
  TError = unknown,
>(
  params?: MaybeRef<GetAll1Params>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAll1>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getGetAll1QueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getAll1>>> = ({
    signal,
  }) => getAll1(params, signal);

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getAll1>>, TError, TData>;
};

export type GetAll1QueryResult = NonNullable<
  Awaited<ReturnType<typeof getAll1>>
>;
export type GetAll1QueryError = unknown;

/**
 * @summary Get all clothing items with pagination
 */

export function useGetAll1<
  TData = Awaited<ReturnType<typeof getAll1>>,
  TError = unknown,
>(
  params?: MaybeRef<GetAll1Params>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getAll1>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetAll1QueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * @summary Create a new clothing item
 */
export const create1 = (
  clothingItem: MaybeRef<ClothingItem>,
  signal?: AbortSignal,
) => {
  clothingItem = unref(clothingItem);

  return customInstance<ClothingItem>({
    url: `/api/clothing-items`,
    method: "POST",
    headers: { "Content-Type": "application/json" },
    data: clothingItem,
    signal,
  });
};

export const getCreate1MutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof create1>>,
    TError,
    { data: ClothingItem },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof create1>>,
  TError,
  { data: ClothingItem },
  TContext
> => {
  const mutationKey = ["create1"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof create1>>,
    { data: ClothingItem }
  > = (props) => {
    const { data } = props ?? {};

    return create1(data);
  };

  return { mutationFn, ...mutationOptions };
};

export type Create1MutationResult = NonNullable<
  Awaited<ReturnType<typeof create1>>
>;
export type Create1MutationBody = ClothingItem;
export type Create1MutationError = unknown;

/**
 * @summary Create a new clothing item
 */
export const useCreate1 = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof create1>>,
      TError,
      { data: ClothingItem },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof create1>>,
  TError,
  { data: ClothingItem },
  TContext
> => {
  const mutationOptions = getCreate1MutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Toggle favorite status of a clothing item
 */
export const toggleFavorite = (id: MaybeRef<number>, signal?: AbortSignal) => {
  id = unref(id);

  return customInstance<ClothingItem>({
    url: `/api/clothing-items/${id}/favorite`,
    method: "POST",
    signal,
  });
};

export const getToggleFavoriteMutationOptions = <
  TError = unknown,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof toggleFavorite>>,
    TError,
    { id: number },
    TContext
  >;
}): UseMutationOptions<
  Awaited<ReturnType<typeof toggleFavorite>>,
  TError,
  { id: number },
  TContext
> => {
  const mutationKey = ["toggleFavorite"];
  const { mutation: mutationOptions } = options
    ? options.mutation &&
      "mutationKey" in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey } };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof toggleFavorite>>,
    { id: number }
  > = (props) => {
    const { id } = props ?? {};

    return toggleFavorite(id);
  };

  return { mutationFn, ...mutationOptions };
};

export type ToggleFavoriteMutationResult = NonNullable<
  Awaited<ReturnType<typeof toggleFavorite>>
>;

export type ToggleFavoriteMutationError = unknown;

/**
 * @summary Toggle favorite status of a clothing item
 */
export const useToggleFavorite = <TError = unknown, TContext = unknown>(
  options?: {
    mutation?: UseMutationOptions<
      Awaited<ReturnType<typeof toggleFavorite>>,
      TError,
      { id: number },
      TContext
    >;
  },
  queryClient?: QueryClient,
): UseMutationReturnType<
  Awaited<ReturnType<typeof toggleFavorite>>,
  TError,
  { id: number },
  TContext
> => {
  const mutationOptions = getToggleFavoriteMutationOptions(options);

  return useMutation(mutationOptions, queryClient);
};
/**
 * @summary Get clothing items by tag
 */
export const getByTag = (
  tag: MaybeRef<string>,
  params?: MaybeRef<GetByTagParams>,
  signal?: AbortSignal,
) => {
  tag = unref(tag);
  params = unref(params);

  return customInstance<PageClothingItem>({
    url: `/api/clothing-items/tag/${tag}`,
    method: "GET",
    params: unref(params),
    signal,
  });
};

export const getGetByTagQueryKey = (
  tag: MaybeRef<string>,
  params?: MaybeRef<GetByTagParams>,
) => {
  return [
    "api",
    "clothing-items",
    "tag",
    tag,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetByTagInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof getByTag>>,
    GetByTagParams["page"]
  >,
  TError = unknown,
>(
  tag: MaybeRef<string>,
  params?: MaybeRef<GetByTagParams>,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getByTag>>,
        TError,
        TData,
        Awaited<ReturnType<typeof getByTag>>,
        QueryKey,
        GetByTagParams["page"]
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getGetByTagQueryKey(tag, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getByTag>>,
    QueryKey,
    GetByTagParams["page"]
  > = ({ signal, pageParam }) =>
    getByTag(
      tag,
      { ...unref(params), page: pageParam || unref(params)?.["page"] },
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(tag)),
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getByTag>>,
    TError,
    TData,
    Awaited<ReturnType<typeof getByTag>>,
    QueryKey,
    GetByTagParams["page"]
  >;
};

export type GetByTagInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getByTag>>
>;
export type GetByTagInfiniteQueryError = unknown;

/**
 * @summary Get clothing items by tag
 */

export function useGetByTagInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof getByTag>>,
    GetByTagParams["page"]
  >,
  TError = unknown,
>(
  tag: MaybeRef<string>,
  params?: MaybeRef<GetByTagParams>,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getByTag>>,
        TError,
        TData,
        Awaited<ReturnType<typeof getByTag>>,
        QueryKey,
        GetByTagParams["page"]
      >
    >;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetByTagInfiniteQueryOptions(tag, params, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

export const getGetByTagQueryOptions = <
  TData = Awaited<ReturnType<typeof getByTag>>,
  TError = unknown,
>(
  tag: MaybeRef<string>,
  params?: MaybeRef<GetByTagParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getByTag>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getGetByTagQueryKey(tag, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getByTag>>> = ({
    signal,
  }) => getByTag(tag, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(tag)),
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof getByTag>>, TError, TData>;
};

export type GetByTagQueryResult = NonNullable<
  Awaited<ReturnType<typeof getByTag>>
>;
export type GetByTagQueryError = unknown;

/**
 * @summary Get clothing items by tag
 */

export function useGetByTag<
  TData = Awaited<ReturnType<typeof getByTag>>,
  TError = unknown,
>(
  tag: MaybeRef<string>,
  params?: MaybeRef<GetByTagParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getByTag>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetByTagQueryOptions(tag, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * @summary Search clothing items by name
 */
export const searchByName = (
  params: MaybeRef<SearchByNameParams>,
  signal?: AbortSignal,
) => {
  params = unref(params);

  return customInstance<PageClothingItem>({
    url: `/api/clothing-items/search`,
    method: "GET",
    params: unref(params),
    signal,
  });
};

export const getSearchByNameQueryKey = (
  params: MaybeRef<SearchByNameParams>,
) => {
  return [
    "api",
    "clothing-items",
    "search",
    ...(params ? [params] : []),
  ] as const;
};

export const getSearchByNameInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof searchByName>>,
    SearchByNameParams["page"]
  >,
  TError = unknown,
>(
  params: MaybeRef<SearchByNameParams>,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof searchByName>>,
        TError,
        TData,
        Awaited<ReturnType<typeof searchByName>>,
        QueryKey,
        SearchByNameParams["page"]
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getSearchByNameQueryKey(params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof searchByName>>,
    QueryKey,
    SearchByNameParams["page"]
  > = ({ signal, pageParam }) =>
    searchByName(
      { ...unref(params), page: pageParam || unref(params)?.["page"] },
      signal,
    );

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof searchByName>>,
    TError,
    TData,
    Awaited<ReturnType<typeof searchByName>>,
    QueryKey,
    SearchByNameParams["page"]
  >;
};

export type SearchByNameInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof searchByName>>
>;
export type SearchByNameInfiniteQueryError = unknown;

/**
 * @summary Search clothing items by name
 */

export function useSearchByNameInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof searchByName>>,
    SearchByNameParams["page"]
  >,
  TError = unknown,
>(
  params: MaybeRef<SearchByNameParams>,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof searchByName>>,
        TError,
        TData,
        Awaited<ReturnType<typeof searchByName>>,
        QueryKey,
        SearchByNameParams["page"]
      >
    >;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSearchByNameInfiniteQueryOptions(params, options);

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

export const getSearchByNameQueryOptions = <
  TData = Awaited<ReturnType<typeof searchByName>>,
  TError = unknown,
>(
  params: MaybeRef<SearchByNameParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof searchByName>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getSearchByNameQueryKey(params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof searchByName>>> = ({
    signal,
  }) => searchByName(params, signal);

  return {
    queryKey,
    queryFn,
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<Awaited<ReturnType<typeof searchByName>>, TError, TData>;
};

export type SearchByNameQueryResult = NonNullable<
  Awaited<ReturnType<typeof searchByName>>
>;
export type SearchByNameQueryError = unknown;

/**
 * @summary Search clothing items by name
 */

export function useSearchByName<
  TData = Awaited<ReturnType<typeof searchByName>>,
  TError = unknown,
>(
  params: MaybeRef<SearchByNameParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof searchByName>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getSearchByNameQueryOptions(params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * @summary Get clothing items by event type
 */
export const getByEventType = (
  eventType: MaybeRef<
    | "DAY"
    | "NIGHT"
    | "DATE"
    | "CASUAL"
    | "BEACH"
    | "SCHOOL"
    | "FORMAL"
    | "SPORTS"
    | "WORK"
  >,
  params?: MaybeRef<GetByEventTypeParams>,
  signal?: AbortSignal,
) => {
  eventType = unref(eventType);
  params = unref(params);

  return customInstance<PageClothingItem>({
    url: `/api/clothing-items/event-type/${eventType}`,
    method: "GET",
    params: unref(params),
    signal,
  });
};

export const getGetByEventTypeQueryKey = (
  eventType: MaybeRef<
    | "DAY"
    | "NIGHT"
    | "DATE"
    | "CASUAL"
    | "BEACH"
    | "SCHOOL"
    | "FORMAL"
    | "SPORTS"
    | "WORK"
  >,
  params?: MaybeRef<GetByEventTypeParams>,
) => {
  return [
    "api",
    "clothing-items",
    "event-type",
    eventType,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetByEventTypeInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof getByEventType>>,
    GetByEventTypeParams["page"]
  >,
  TError = unknown,
>(
  eventType: MaybeRef<
    | "DAY"
    | "NIGHT"
    | "DATE"
    | "CASUAL"
    | "BEACH"
    | "SCHOOL"
    | "FORMAL"
    | "SPORTS"
    | "WORK"
  >,
  params?: MaybeRef<GetByEventTypeParams>,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getByEventType>>,
        TError,
        TData,
        Awaited<ReturnType<typeof getByEventType>>,
        QueryKey,
        GetByEventTypeParams["page"]
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getGetByEventTypeQueryKey(eventType, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getByEventType>>,
    QueryKey,
    GetByEventTypeParams["page"]
  > = ({ signal, pageParam }) =>
    getByEventType(
      eventType,
      { ...unref(params), page: pageParam || unref(params)?.["page"] },
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(eventType)),
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getByEventType>>,
    TError,
    TData,
    Awaited<ReturnType<typeof getByEventType>>,
    QueryKey,
    GetByEventTypeParams["page"]
  >;
};

export type GetByEventTypeInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getByEventType>>
>;
export type GetByEventTypeInfiniteQueryError = unknown;

/**
 * @summary Get clothing items by event type
 */

export function useGetByEventTypeInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof getByEventType>>,
    GetByEventTypeParams["page"]
  >,
  TError = unknown,
>(
  eventType: MaybeRef<
    | "DAY"
    | "NIGHT"
    | "DATE"
    | "CASUAL"
    | "BEACH"
    | "SCHOOL"
    | "FORMAL"
    | "SPORTS"
    | "WORK"
  >,
  params?: MaybeRef<GetByEventTypeParams>,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getByEventType>>,
        TError,
        TData,
        Awaited<ReturnType<typeof getByEventType>>,
        QueryKey,
        GetByEventTypeParams["page"]
      >
    >;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetByEventTypeInfiniteQueryOptions(
    eventType,
    params,
    options,
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

export const getGetByEventTypeQueryOptions = <
  TData = Awaited<ReturnType<typeof getByEventType>>,
  TError = unknown,
>(
  eventType: MaybeRef<
    | "DAY"
    | "NIGHT"
    | "DATE"
    | "CASUAL"
    | "BEACH"
    | "SCHOOL"
    | "FORMAL"
    | "SPORTS"
    | "WORK"
  >,
  params?: MaybeRef<GetByEventTypeParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getByEventType>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getGetByEventTypeQueryKey(eventType, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getByEventType>>> = ({
    signal,
  }) => getByEventType(eventType, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(eventType)),
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getByEventType>>,
    TError,
    TData
  >;
};

export type GetByEventTypeQueryResult = NonNullable<
  Awaited<ReturnType<typeof getByEventType>>
>;
export type GetByEventTypeQueryError = unknown;

/**
 * @summary Get clothing items by event type
 */

export function useGetByEventType<
  TData = Awaited<ReturnType<typeof getByEventType>>,
  TError = unknown,
>(
  eventType: MaybeRef<
    | "DAY"
    | "NIGHT"
    | "DATE"
    | "CASUAL"
    | "BEACH"
    | "SCHOOL"
    | "FORMAL"
    | "SPORTS"
    | "WORK"
  >,
  params?: MaybeRef<GetByEventTypeParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getByEventType>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetByEventTypeQueryOptions(
    eventType,
    params,
    options,
  );

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

/**
 * @summary Get clothing items by category
 */
export const getByCategory = (
  category: MaybeRef<
    "TOP" | "BOTTOM" | "DRESS" | "OUTERWEAR" | "SHOES" | "ACCESSORY" | "OUTFIT"
  >,
  params?: MaybeRef<GetByCategoryParams>,
  signal?: AbortSignal,
) => {
  category = unref(category);
  params = unref(params);

  return customInstance<PageClothingItem>({
    url: `/api/clothing-items/category/${category}`,
    method: "GET",
    params: unref(params),
    signal,
  });
};

export const getGetByCategoryQueryKey = (
  category: MaybeRef<
    "TOP" | "BOTTOM" | "DRESS" | "OUTERWEAR" | "SHOES" | "ACCESSORY" | "OUTFIT"
  >,
  params?: MaybeRef<GetByCategoryParams>,
) => {
  return [
    "api",
    "clothing-items",
    "category",
    category,
    ...(params ? [params] : []),
  ] as const;
};

export const getGetByCategoryInfiniteQueryOptions = <
  TData = InfiniteData<
    Awaited<ReturnType<typeof getByCategory>>,
    GetByCategoryParams["page"]
  >,
  TError = unknown,
>(
  category: MaybeRef<
    "TOP" | "BOTTOM" | "DRESS" | "OUTERWEAR" | "SHOES" | "ACCESSORY" | "OUTFIT"
  >,
  params?: MaybeRef<GetByCategoryParams>,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getByCategory>>,
        TError,
        TData,
        Awaited<ReturnType<typeof getByCategory>>,
        QueryKey,
        GetByCategoryParams["page"]
      >
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getGetByCategoryQueryKey(category, params);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof getByCategory>>,
    QueryKey,
    GetByCategoryParams["page"]
  > = ({ signal, pageParam }) =>
    getByCategory(
      category,
      { ...unref(params), page: pageParam || unref(params)?.["page"] },
      signal,
    );

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(category)),
    staleTime: 10000,
    ...queryOptions,
  } as UseInfiniteQueryOptions<
    Awaited<ReturnType<typeof getByCategory>>,
    TError,
    TData,
    Awaited<ReturnType<typeof getByCategory>>,
    QueryKey,
    GetByCategoryParams["page"]
  >;
};

export type GetByCategoryInfiniteQueryResult = NonNullable<
  Awaited<ReturnType<typeof getByCategory>>
>;
export type GetByCategoryInfiniteQueryError = unknown;

/**
 * @summary Get clothing items by category
 */

export function useGetByCategoryInfinite<
  TData = InfiniteData<
    Awaited<ReturnType<typeof getByCategory>>,
    GetByCategoryParams["page"]
  >,
  TError = unknown,
>(
  category: MaybeRef<
    "TOP" | "BOTTOM" | "DRESS" | "OUTERWEAR" | "SHOES" | "ACCESSORY" | "OUTFIT"
  >,
  params?: MaybeRef<GetByCategoryParams>,
  options?: {
    query?: Partial<
      UseInfiniteQueryOptions<
        Awaited<ReturnType<typeof getByCategory>>,
        TError,
        TData,
        Awaited<ReturnType<typeof getByCategory>>,
        QueryKey,
        GetByCategoryParams["page"]
      >
    >;
  },
  queryClient?: QueryClient,
): UseInfiniteQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetByCategoryInfiniteQueryOptions(
    category,
    params,
    options,
  );

  const query = useInfiniteQuery(
    queryOptions,
    queryClient,
  ) as UseInfiniteQueryReturnType<TData, TError> & {
    queryKey: DataTag<QueryKey, TData, TError>;
  };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}

export const getGetByCategoryQueryOptions = <
  TData = Awaited<ReturnType<typeof getByCategory>>,
  TError = unknown,
>(
  category: MaybeRef<
    "TOP" | "BOTTOM" | "DRESS" | "OUTERWEAR" | "SHOES" | "ACCESSORY" | "OUTFIT"
  >,
  params?: MaybeRef<GetByCategoryParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getByCategory>>, TError, TData>
    >;
  },
) => {
  const { query: queryOptions } = options ?? {};

  const queryKey = getGetByCategoryQueryKey(category, params);

  const queryFn: QueryFunction<Awaited<ReturnType<typeof getByCategory>>> = ({
    signal,
  }) => getByCategory(category, params, signal);

  return {
    queryKey,
    queryFn,
    enabled: computed(() => !!unref(category)),
    staleTime: 10000,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof getByCategory>>,
    TError,
    TData
  >;
};

export type GetByCategoryQueryResult = NonNullable<
  Awaited<ReturnType<typeof getByCategory>>
>;
export type GetByCategoryQueryError = unknown;

/**
 * @summary Get clothing items by category
 */

export function useGetByCategory<
  TData = Awaited<ReturnType<typeof getByCategory>>,
  TError = unknown,
>(
  category: MaybeRef<
    "TOP" | "BOTTOM" | "DRESS" | "OUTERWEAR" | "SHOES" | "ACCESSORY" | "OUTFIT"
  >,
  params?: MaybeRef<GetByCategoryParams>,
  options?: {
    query?: Partial<
      UseQueryOptions<Awaited<ReturnType<typeof getByCategory>>, TError, TData>
    >;
  },
  queryClient?: QueryClient,
): UseQueryReturnType<TData, TError> & {
  queryKey: DataTag<QueryKey, TData, TError>;
} {
  const queryOptions = getGetByCategoryQueryOptions(category, params, options);

  const query = useQuery(queryOptions, queryClient) as UseQueryReturnType<
    TData,
    TError
  > & { queryKey: DataTag<QueryKey, TData, TError> };

  query.queryKey = unref(queryOptions).queryKey as DataTag<
    QueryKey,
    TData,
    TError
  >;

  return query;
}
